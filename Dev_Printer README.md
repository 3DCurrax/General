# Dev_Printer
### PrinterExec program development, C++, vstudio, linux

This is a repo for the development of the PrinterExec program. The PrinterExec program runs on the Tinker Board and is
used to run print jobs.
   1. PrinterExec is a command line executive program that runs under linux on the tinkerboard.
   2. It communicates with the Feynman board via two usb serial channels: ttyACM0 for gcodes and ttyACM1 for messages.
   2. It executes print jobs that are defined by zip files that contain a gcode file and a set of .png slicer files
   4. It can also execute print jobs for standalone gcode files, with out the .png slicer files.
      
This program is written for Linux in Visual Studio. The use of Visual Studio provides for the software development to be done on a Windows laptop, while the program executes on the Linux ARM tinkerboard. Realtime functionality is provided by the RisLib realtime infrastucture library. Graphics functionality is provided by the SDL2 and SDL2image libraries.

## Solution Projects
``` markdown
CommonLib        -- common library -- byte content messages and settings 
FComm            -- Test program for the Feynman message channel
GPIO             -- GPIO test program.
LcdGraphics      -- Graphics test program. It writes to the screen and loads .png images
LogThread        -- Log file thread test program.
PipeClient       -- Named pipe client test program.
PipeTest         -- Named pipe general test program.
PrinterExec      -- This is the main program.
Session          -- Test program for file manager operations.
Test             -- general test project.
```
 
# User Manual
## TinkerBoard Program Directory Structure
PrinterExec runs print jobs on the tinkerboard. The print jobs are defined by .zip files that contain a .gcode file and a set of .prn image files. Print jobs can also be defined by standalone .gcode files. PrinterExec writes to a log file: EventLog.txt. Here are the relevant directories on the tinkerboard.

``` markdown
/opt/cprint         -- main program directory
/opt/cprint/zip     -- put job zip files here
/opt/cprint/gcode   -- put standalone gcode files here
/opt/cprint/work    -- print jobs execute from here
/opt/cprint/log     -- log files: WorkLog.txt, ProgramLog.txt
/opt/cprint/files   -- settings files: ProgramParms.txt
/opt/cprint/fifos   -- named pipes for chromium 
/opt/cprint/bin     -- executable files: PrinterExec.out
```
## Running the program
PrinterExec can run a print job in two different ways:
   1. From a zip file that contains a .gcode file and a set of .png image files. The zip file is generated by the  slicer program.
   2. From a standalone .gcode file, without any .png image files. This is useful for test purposes.
   
From a laptop: Using scp, copy .zip files that contain print jobs to /opt/cprint/zip or copy standalone .gcode files to /opt/cprint/gcode

``` markdown
1. Copy the files to the tinkerboard    -- winscp on windows is good
2. Log onto the tinkerboard via ssh     -- openssh on windows is good, putty is bad
3. cd /opt/cprint                       -- this brings you to /opt/cprint
4. ./go.sh                              -- this runs /opt/cprint/bin/PrinterExec.out
5. Enter commands
```
  
## Program User Commands
Commands are typed into the program command line and followed by pressing enter. They have a format of "cmd arg1 arg2 ..." where the arguments are separated by white space.

``` markdown
dirz           -- list zip files in the zip directory
runz #n        -- run with a zip file with file number from the dirz command
testz #n       -- test a zip file with file number from the dirz command

dirg           -- list gcode files in the gcode directory
rung #n        -- run with a gcode file with file number from the dirg command

send something -- send a gcode command to the feynman

help           -- show help

e              -- exit the program

a              -- abort a running script
s              -- suspend a running script (at the next <Mark> gcode command
r              -- resume a suspended script

o              -- disable console prints
p              -- enable console prints

0              -- console prints don't show status
1              -- console prints show sent gcodes and received responses
2              -- console prints show gcode and slice counts and various state information

```

To run a print job on a .zip file, enter "dirz" to list the names of the zip files in the zip directory. For each file in the zip directory, this lists a file number and a file name. Enter the command "runz n", where n is the file number from the "dirz" command.

To run a print job on a .gcode file, enter "dirg" to list the names of the .gcode files in the gcode directory. For each file in the gcode directory, this lists a file number and a file name. Enter the command "rung n", where n is the file number from the "dirg" command.

To manually send a gcode command to the feynman, enter something like "send M105" or "send G1 Z6 F300"

Program events are logged to /opt/cprint/log/WorkLog.txt. Currently the log files isn't updated until after the program is closed, so you have to exit the program before reading it.

## Program Status Console Prints

Different program status information can be displayed by console status prints.

F1 selects showing gcodes that are sent to the Feynman and responses that are received from the Feynman.

F2 selects showing various status information periodicaly.

Here's a snapshot when a script is not running.

``` markdown
Status 1361 $   582   748 $ stopped
Status 1362 $   582   748 $ stopped
Status 1363 $   582   748 $ stopped
Status 1364 $   582   748 $ stopped
Status 1365 $   582   748 $ stopped
Status 1366 $   582   748 $ stopped
Status 1367 $   582   748 $ stopped
Status 1368 $   582   748 $ stopped
Status 1369 $   582   748 $ stopped
```
Each row shows the following columns:
1. Label.
2. Count that increments with each status update.
3. Number of transmitted gcodes.
4. Number of received gcode responses.
5. Current script state.

Here's a snapshot when a script is running.

``` markdown
Status   53 00:00:32 $   148   190 $ running    0 none
Status   54 00:00:33 $   155   199 $ running    0 none
Status   55 00:00:34 $   157   202 $ running    0 none
Status   56 00:00:35 $   162   208 $ running    0 none
Status   57 00:00:36 $   167   214 $ running    0 none
Status   58 00:00:37 $   169   217 $ running    0 none
Status   59 00:00:38 $   176   226 $ running    0 none
Status   60 00:00:39 $   181   232 $ running    0 none
Status   61 00:00:40 $   183   235 $ running    0 none
Status   62 00:00:41 $   190   244 $ running    0 none
Status   63 00:00:42 $   193   247 $ running    0 none
Status   64 00:00:43 $   197   253 $ running    0 none
Status   65 00:00:44 $   204   262 $ running    0 none
Status   66 00:00:45 $   206   264 $ running    0 none
```
Each row shows the following columns:
1. Label.
2. Count that increments with each status update.
3. Run time for the current script.
4. Number of transmitted gcodes.
5. Number of received gcode responses.
6. Current script state.
7. Current slice count.
8. Current script sub state.



## Named Pipe Interface

PrinterExec provides a named pipe interface that can be used by a chromium web page that runs on the touch screen.

Here are the named pipes:
``` markdown
/opt/cprint/fifos/printer_exec_command_input_fifo      -- PrinterExec reads command strings from this named pipe.
/opt/cprint/fifos/printer_exec_response_output_fifo    -- PrinterExec writes response strings to this named pipe.
/opt/cprint/fifos/printer_status_output_fifo           -- PrinterExec writes periodic status strings to this names pipe.
```

### Commands and Responses
PrinterExec reads commands that are written to the command fifo. It executes the commands and writes responses to the response fifo. The commands and responses are strings that are terminated with a newline (\n,10). Command strings are in a command line format "command argument1 argument2 argumant3 ..." where terms are separated by nullspace. Response strings are of the form "ack/nak MESSAGE".

The __runzip__ command runs a script from a zip file. An __ack__ response is sent when the script starts and another __ack__ response is sent when the script completes. If there is an error in the command then a __nak__ response is sent.

``` markdown
command:   "runzip MyFile.zip"
response:  "ack SCRIPT RUNNING"
response:  "done SCRIPT COMPLETED"

command:   "send runzip Test101.zip22"
response:  "nak ERROR Zip File does not exist ./zip/Test101.zip22"
```
The __rungcode__ command runs a script from a gcode file. An __ack__ response is sent when the script starts and another __ack__ response is sent when the script completes. If there is an error in the command then a __nak__ response is sent.

``` markdown
command:   "rungcode MyFile.gcode"
response:  "ack SCRIPT RUNNING"
response:  "done SCRIPT COMPLETED"
```
The __sendgcode__ command directly send a gcode to the Feynman. An __ack__ response is sent when the gcode is sent.

``` markdown
command:   "sendgcode M105"
command:   "ack"
```

### Periodic Status
PrinterExec periodically sends a status string that contains name value pairs of various program status variables. The string contains a concatenation of name value pairs that are enclosed in braces and succeeded by commas. The string is terminated with a newline (\n,10).

The status string has the form "{name1:value1},{name2:value2},...{namen:valuen}\n".

Here's an example:
{Count:269},{State:"running"},{SubState:"none"},{GCodeTxCount:267},{GCodeRxCount:343},{SliceCount:0},{RunTime:"00:01:00"}

The available name value pairs are:

``` markdown
{Count:int}          -- Count that increments with each status update.
{State:"string"}     -- Current script state:none,running,paused,stopped,aborted 
{SubState:"string"}  -- Current script sub state.
{Cycle:"string"}     -- Current script cycle.
{Layer:"string"}     -- Current script layer.
{Phase:"string"}     -- Current script phase.
{GCodeTxCount:int}   -- Number of transmitted gcodes.
{GCodeRxCount:int}   -- Number of received gcode responses.
{SliceCount:int}     -- Current slice count.
{RunTime:"string"}   -- Run time for the current script. HH:MM:SS.
```

